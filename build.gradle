import com.typesafe.config.*;

apply plugin: 'base'
apply plugin: 'js'

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath('com.typesafe:config:1.1.0-9f31d6308e7ebbc3d7904b64ebb9f61f7e22a968') {
            exclude(group: 'com.typesafe.sbteclipse')
        }
        classpath('com.eriwen:gradle-js-plugin:1.9.0')
    }
}

version = buildVersion
group = "com.dev9.github.jsonconfig"
description = "dev9 configuration compiler"
    
ext {
    artifactId = "config-json"
    environments = ['default', 'dev', 'qa', 'stage', 'prod']
    bundles = fileTree(dir: 'src/main/bundles', include: '*.conf').files*.name*.replace('.conf', '')
    workOutputFile = file("${buildDir}/work/work.conf")
    resolvePartial = ConfigResolveOptions.defaults().setAllowUnresolved(true)
}

defaultTasks 'assemble'
tasks.assemble.dependsOn 'bundle'

task bundle (dependsOn: 'generate', type: Tar) {
    description = "Creates the final tar.gz archive of the generated config files"
    compression = Compression.GZIP
    into "${artifactId}-${version}"
    from("${buildDir}") {
        exclude "distributions"
        exclude "work"
    }
}

task generate {
    environments.each { 
        dependsOn "gen_${it}" 
    }
}

environments.each { env ->
    // Generate a master task to generate all files for one env
    task "gen_${env}"(dependsOn: ["gen_${env}_full", "gen_${env}_bundles"]) {

    }

    // Generate the full config for this environment
    task "gen_${env}_full"(dependsOn: 'mergeConfigFiles') {
        ext.outputFile = file("${buildDir}/${env}/config.json")

        inputs.file(workOutputFile)
        outputs.file(outputFile)

        doLast {
            def config = ConfigFactory.parseFile(workOutputFile)
            def envConfig = config.hasPath(env) ? config.getConfig(env) : ConfigFactory.empty()
            envConfig = envConfig.withFallback(config.getConfig('default')).resolve(resolvePartial).resolveWith(config, resolvePartial)

            outputFile.write(pretty(envConfig))
        }
    }
    
    // This bundles task adds dependencies on all the individual bundle tasks
    task "gen_${env}_bundles" {
        bundles.each { 
            dependsOn "gen_${env}_bundle_${it}" 
        }
    }

    bundles.each { bundle -> 
        task "gen_${env}_bundle_${bundle}"(dependsOn: "gen_${env}_full") {
            ext.bundleFile = file("src/main/bundles/${bundle}.conf")
            ext.inputFile = file("${buildDir}/${env}/config.json")
            ext.outputFile = file("${buildDir}/${env}/${bundle}.json")

            inputs.files(bundleFile, inputFile)
            outputs.file(outputFile)

            doLast {
                def fullConfig = ConfigFactory.parseFile(inputFile)
                def bundleConfig = ConfigFactory.parseFile(bundleFile)
                def bundleOutput = ConfigFactory.empty();

                if ( bundleConfig.hasPath('includes') )
                {
                    bundleConfig.getStringList('includes').each { include -> 
                        bundleOutput = bundleOutput.withFallback(fullConfig.getObject(include).atPath(include))
                    }
                }
                else
                {
                    bundleOutput = bundleOutput.withFallback(fullConfig)   
                }

                if ( bundleConfig.hasPath('remove') )
                {
                    bundleConfig.getStringList('remove').each { remove ->
                        if ( bundleOutput.hasPath(remove) )
                            bundleOutput = bundleOutput.withoutPath(remove)
                    }
                }

                outputFile.write(pretty(bundleOutput.resolve(resolvePartial)))
            }
        }
    }
}

task createWorkingDirectories {
    environments.each { 
        outputs.file(file("${buildDir}/${it}"))
    }

    doLast {
        environments.each { 
            file("${buildDir}/${it}").mkdirs()
        }
    }
}

task mergeConfigFiles(dependsOn: 'createWorkingDirectories', type: com.eriwen.gradle.js.tasks.CombineJsTask) {
    source = fileTree(dir: 'src/main/conf', include: '*.conf')
    dest = workOutputFile

    doLast {
        workOutputFile.append("\ndefault {\n    configVersion: ${version}\n}\n\n")
    }
}

jshint {  
    // Depends on our generation task
    tasks.jshint.dependsOn 'generate'

    // This plugin has a weird naming issue (http://forums.gradle.org/gradle/topics/gradle_js_plugin)
    // Prefixing config with tasks.jshint seems to fix it. 
    tasks.jshint.source = fileTree(dir: buildDir, include: "**/*.json")
    tasks.jshint.dest = file("${buildDir}/jshint.out")  
    tasks.jshint.outputToStdOut = true  
    tasks.jshint.ignoreExitCode = false

    jshint.options = [expr: "true", unused: "true"]  
}

def pretty(Config config) {
    config.root().render(ConfigRenderOptions.concise().setFormatted(true))
}

def prettyPrint(Config config) {
    println pretty(config)
}

// This task gets the gradlew scripts and the jar file for us.
// Use this to upgrade gradle versions. 
task createWrapper(type: Wrapper) {
    gradleVersion = '1.10'
}
